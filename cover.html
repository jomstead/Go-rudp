
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jomstead/go-rudp/client/rudp_client.go (95.6%)</option>
				
				<option value="file1">github.com/jomstead/go-rudp/packet/packet.go (100.0%)</option>
				
				<option value="file2">github.com/jomstead/go-rudp/rudp.go (90.0%)</option>
				
				<option value="file3">github.com/jomstead/go-rudp/server/rudp_server.go (96.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "encoding/binary"
        "errors"
        "net"
        "time"

        "github.com/jomstead/go-rudp/packet"
)

type RUDPClient struct {
        conn               *net.UDPConn
        address            *net.UDPAddr //host:port
        seq                uint32
        isConnected        bool
        remote_seq         uint32
        remote_acks        packet.Ack
        temp               []byte          // temp is used to read in a packet from the remote source and processed for reliable UDP, it is then copied to a new buffer without the RUDP bytes for processing outside the api
        sent_packet_buffer []packet.Packet // keeps a buffer of sent reliable packets, packets get removed from this slice as they are confirm received
}

func (conn *RUDPClient) Close() <span class="cov1" title="1">{
        if conn.conn != nil </span><span class="cov1" title="1">{
                conn.conn.Close()
        }</span>
        <span class="cov1" title="1">conn.isConnected = false</span>
}

func (conn RUDPClient) IsConnected() bool <span class="cov1" title="1">{
        return conn.isConnected
}</span>
func (conn *RUDPClient) Initialize(c *net.UDPConn, a *net.UDPAddr) <span class="cov4" title="2">{
        conn.isConnected = true                                // is the client 'connected'
        conn.address = a                                       // address of the remote server
        conn.conn = c                                          // connection to the remote server
        conn.seq = ^uint32(0)                                  //seq number
        conn.remote_seq = ^uint32(0)                           // remote seq number
        conn.sent_packet_buffer = make([]packet.Packet, 0, 16) // queue of outbound reliable packets
        conn.temp = make([]byte, 1024)                         // buffer used for receiving packets
        conn.remote_acks = packet.Ack{Data: 0}

}</span>

/* Write sends a packet to the dialed connection */
func (conn *RUDPClient) Write(payload *[]byte, reliable bool) (int, error) <span class="cov4" title="2">{
        // Create the packet [Reliable][Seq][Remote_seq][remote_acks][Payload]
        var data []byte
        var seq uint32
        index := 0
        if reliable </span><span class="cov1" title="1">{
                data = make([]byte, 13, len(*payload)+13)
                data[0] = 1
                // increase sequence number for reliable packets
                conn.seq += 1
                seq = conn.seq
                binary.BigEndian.PutUint32(data[1:], conn.seq)
                index = 5
        }</span> else<span class="cov1" title="1"> {
                data = make([]byte, 9, len(*payload)+9)
                index = 1
        }</span>
        // include the last received sequence number and the sequence history from the remote source
        <span class="cov4" title="2">binary.BigEndian.PutUint32(data[index:], conn.remote_seq)
        binary.BigEndian.PutUint32(data[index+4:], conn.remote_acks.Data)
        index += 8
        data = append(data, *payload...)
        if reliable </span><span class="cov1" title="1">{
                // save packets incase we need to resend them
                conn.sent_packet_buffer = append(conn.sent_packet_buffer, packet.Packet{Seq: seq, Data: data, Timestamp: time.Now().UnixMilli()})
        }</span>
        <span class="cov4" title="2">n, err := conn.conn.Write(data)
        return n - index, err</span>
}

func (conn RUDPClient) ReadFromUDP(buffer []byte) (n int, addr *net.UDPAddr, err error) <span class="cov7" title="4">{
        if buffer == nil </span><span class="cov1" title="1">{
                return 0, nil, errors.New("buffer cannot be nil")
        }</span>
        <span class="cov6" title="3">n, addr, err = conn.conn.ReadFromUDP(conn.temp)
        if err != nil </span><span class="cov0" title="0">{
                return n, addr, err
        }</span>
        <span class="cov6" title="3">if n &gt; 5 &amp;&amp; conn.temp[0] == 0 </span><span class="cov1" title="1">{
                // unreliable packet
                ack := binary.BigEndian.Uint32(conn.temp[1:5])
                ack_bitfield := binary.BigEndian.Uint32(conn.temp[5:9])
                if len(buffer) &lt; n-9 </span><span class="cov0" title="0">{
                        return 0, nil, errors.New("buffer too small for packet")
                }</span>
                <span class="cov1" title="1">conn.processAck(ack, ack_bitfield)
                copy(buffer, conn.temp[9:n])
                return n - 9, addr, err</span>
        }
        <span class="cov4" title="2">if n &gt; 8 &amp;&amp; conn.temp[0] == 1 </span><span class="cov1" title="1">{
                // reliable packet
                seq := binary.BigEndian.Uint32(conn.temp[1:5])
                conn.remote_seq = packet.UpdateAcknowledgements(seq, conn.remote_seq, &amp;conn.remote_acks)
                ack := binary.BigEndian.Uint32(conn.temp[5:9])
                ack_bitfield := binary.BigEndian.Uint32(conn.temp[9:13])
                if len(buffer) &lt; n-13 </span><span class="cov0" title="0">{
                        return 0, nil, errors.New("buffer too small for packet")
                }</span>
                <span class="cov1" title="1">conn.processAck(ack, ack_bitfield)
                copy(buffer, conn.temp[13:n])
                return n - 13, addr, err</span>
        }
        // Not sure what this packet is....
        <span class="cov1" title="1">return 0, addr, errors.New("unexpected RUDP header data")</span>
}

// ProcessAck takes the acknowledgements from the remote resource and removes packets from the local
// reliable packet buffer that have been confirmed as sent
func (conn *RUDPClient) processAck(seq uint32, bitwise uint32) <span class="cov7" title="4">{
        bits := packet.Ack{Data: bitwise}
        count := len(conn.sent_packet_buffer)
        i := 0
        for i &lt; count </span><span class="cov10" title="7">{
                p := conn.sent_packet_buffer[i]
                // check if this packet in the buffer has been verified as delivered.
                // It is verified if either the sequence number is the same as the received sequence number, or
                // if the bitwise bit for that packet is set in the bitwise field(which holds the last 32 acknowledgements)
                if p.Seq == seq || bits.Has(seq-p.Seq-1) </span><span class="cov8" title="5">{
                        //overwrite the packet in the buffer with the last packet in the buffer list
                        conn.sent_packet_buffer[i] = conn.sent_packet_buffer[count-1]
                        // then remove the last packet in the list since we moved it to a new spot in the list
                        count--
                        conn.sent_packet_buffer = conn.sent_packet_buffer[0:count]
                }</span> else<span class="cov4" title="2"> {
                        // check if the packet has taken too long to be verified, which means it was probably lost and
                        // will need to be retransmitted
                        if time.Now().UnixMilli()-p.Timestamp &gt; 200 </span><span class="cov1" title="1">{
                                // it has been 200ms, retransmit the packet and reset the timestamp (use the direct write to the UDP socket)
                                conn.conn.Write(p.Data)
                        }</span>

                        // this packet hasn't been verified, move on to check the next one
                        <span class="cov4" title="2">i++</span>
                }

        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package packet

type Ack struct {
        Data uint32
}

type Packet struct {
        Seq       uint32
        Data      []byte
        Timestamp int64
}

func (a *Ack) Set(flag uint32) <span class="cov6" title="6">{
        flag = PowInts(2, flag)
        a.Data = a.Data | flag
}</span>

func (a *Ack) Clear(flag uint32) <span class="cov1" title="1">{
        flag = PowInts(2, flag)
        a.Data = a.Data &amp;^ flag
}</span>

func (a Ack) Has(flag uint32) bool <span class="cov1" title="1">{
        flag = PowInts(2, flag)
        return a.Data&amp;flag != 0
}</span>

func (a *Ack) Shift(count uint32) <span class="cov5" title="5">{
        a.Data = a.Data &lt;&lt; count
}</span>

func UpdateAcknowledgements(seq uint32, remote uint32, bitfield *Ack) uint32 <span class="cov7" title="9">{
        // shift the remote_acks bitfield by the difference in new vs last sequence number received
        shift := int32(seq - remote)
        if remote != ^uint32(0) </span><span class="cov5" title="5">{
                // this is a packet received with a newer sequence number (received 'in order')
                if shift &gt; 0 </span><span class="cov3" title="2">{
                        // push the current sequence into the history bitfield
                        bitfield.Shift(1)
                        bitfield.Set(0)
                        // shift further if there is a gap in the sequence numbers
                        bitfield.Shift(uint32(shift) - 1)
                }</span> else<span class="cov4" title="3"> {
                        // this is a packet received with an older sequence number (received 'out of order')
                        // set the bitfield for that sequence number as received
                        bitfield.Set(uint32(-shift) - 1)
                }</span>
        }
        // update the remote sequence number if the new seq is larger or if the remote sequence is still the initial value
        <span class="cov7" title="9">if seq &gt; remote || remote == ^uint32(0) </span><span class="cov6" title="6">{
                remote = seq
        }</span>
        <span class="cov7" title="9">return remote</span>
}

// Assumption: n &gt;= 0
func PowInts(x, n uint32) uint32 <span class="cov10" title="22">{
        if n == 0 </span><span class="cov3" title="2">{
                return 1
        }</span>
        <span class="cov9" title="20">if n == 1 </span><span class="cov7" title="9">{
                return x
        }</span>
        <span class="cov7" title="11">y := PowInts(x, n/2)
        if n%2 == 0 </span><span class="cov6" title="7">{
                return y * y
        }</span>
        <span class="cov5" title="4">return x * y * y</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rudp

import (
        "net"
        "strconv"

        "github.com/jomstead/go-rudp/client"
        "github.com/jomstead/go-rudp/server"
)

/*
*        RUDP - Reliable UDP
*        Packet Structure  [Reliable Flag][Sequence number][remote ack][remote bitwise][Payload]
*                Reliable flag - 0 for unreliable, 1 for reliable
*                Sequence number - if reliable then a unique sequencial number is added to each packet
*                Remote Ack - the last received sequence number from the remote connection
*                Remote bitwise - acks for the last 32 remote packets
*                Payload - User provided payload
 */

func Listen(network string, host string, port uint16) (*server.RUDPServer, error) <span class="cov6" title="2">{
        address := host + ":" + strconv.Itoa(int(port))
        s, err := net.ResolveUDPAddr(network, address)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">c, err := net.ListenUDP(network, s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">rudpconn := server.RUDPServer{}
        rudpconn.Initialize(c, s)
        return &amp;rudpconn, nil</span>
}

func Dial(network string, host string, port uint16) (*client.RUDPClient, error) <span class="cov10" title="3">{
        address := host + ":" + strconv.Itoa(int(port))
        s, err := net.ResolveUDPAddr(network, address)
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>
        <span class="cov1" title="1">c, err := net.DialUDP(network, nil, s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">rudpclient := client.RUDPClient{}
        rudpclient.Initialize(c, s)
        return &amp;rudpclient, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package server

import (
        "encoding/binary"
        "errors"
        "log"
        "net"
        "net/netip"
        "time"

        "github.com/jomstead/go-rudp/packet"
)

type RUDPServer struct {
        conn        *net.UDPConn
        address     *net.UDPAddr //host:port
        isConnected bool
        connections map[netip.AddrPort]*rUDPConnection
        temp        []byte
}

type rUDPConnection struct {
        addr               netip.AddrPort
        isConnected        bool
        seq                uint32
        remote_seq         uint32
        remote_acks        packet.Ack
        sent_packet_buffer []packet.Packet // keeps a buffer of sent reliable packets, packets get removed from this slice as they are confirm received
        server             *RUDPServer
}

func (conn *RUDPServer) Initialize(c *net.UDPConn, s *net.UDPAddr) <span class="cov4" title="2">{
        conn.isConnected = true // is the server running
        conn.address = s        // address for the server (this machine)
        conn.conn = c           // connection for the server
        conn.temp = make([]byte, 1024)
        conn.connections = make(map[netip.AddrPort]*rUDPConnection)
}</span>

/* WriteToUDP acts like Write but sends the packet to an UDPAddr */
func (conn *RUDPServer) WriteToUDP(payload *[]byte, addr netip.AddrPort, reliable bool) (int, error) <span class="cov4" title="2">{
        // TODO: Get the next sequence number FOR THAT CONNECTION (UDPAddr)
        client := conn.connections[addr]

        var data []byte
        var seq uint32
        index := 0
        if reliable </span><span class="cov1" title="1">{
                data = make([]byte, 13, len(*payload)+13)
                data[0] = 1
                // increase sequence number for reliable packets
                client.seq += 1
                seq = client.seq
                binary.BigEndian.PutUint32(data[1:], client.seq)
                index = 5
        }</span> else<span class="cov1" title="1"> {
                data = make([]byte, 9, len(*payload)+9)
                data[0] = 0
                index = 1
        }</span>
        // include the last received sequence number and the sequence history from the remote source
        <span class="cov4" title="2">binary.BigEndian.PutUint32(data[index:], client.remote_seq)
        binary.BigEndian.PutUint32(data[index+4:], client.remote_acks.Data)
        index += 8
        data = append(data, *payload...)
        if reliable </span><span class="cov1" title="1">{
                // save packets incase we need to resend them
                client.sent_packet_buffer = append(client.sent_packet_buffer, packet.Packet{Seq: seq, Data: data, Timestamp: time.Now().UnixMilli()})
                log.Printf("Sent to client: %d %d %b", client.seq, client.remote_seq, client.remote_acks.Data)
        }</span> else<span class="cov1" title="1"> {
                log.Printf("Sent to client: %d %b", client.remote_seq, client.remote_acks.Data)

        }</span>
        <span class="cov4" title="2">log.Printf("[S] Sent %d", seq)
        n, err := conn.conn.WriteToUDPAddrPort(data, addr)
        return n - index, err</span>
}

func (conn *RUDPServer) Close() <span class="cov4" title="2">{
        if conn.conn != nil </span><span class="cov4" title="2">{
                conn.conn.Close()
        }</span>
        <span class="cov4" title="2">conn.isConnected = false</span>
}

func (conn RUDPServer) IsConnected() bool <span class="cov1" title="1">{
        return conn.isConnected
}</span>

func (conn *RUDPServer) ReadFromUDP(buffer []byte) (n int, addr *netip.AddrPort, err error) <span class="cov9" title="5">{
        // use a temp buffer to read a packet from that client
        if buffer == nil </span><span class="cov1" title="1">{
                return 0, nil, errors.New("buffer not initialized")
        }</span>
        <span class="cov7" title="4">n, client_addr, err := conn.conn.ReadFromUDPAddrPort(conn.temp)
        addr = &amp;client_addr
        if err != nil </span><span class="cov0" title="0">{
                return n, addr, err
        }</span>
        // create a new rUDPConnection for each new addr
        <span class="cov7" title="4">var client *rUDPConnection
        client = conn.connections[*addr]
        if client == nil </span><span class="cov4" title="2">{
                client = &amp;rUDPConnection{
                        isConnected:        true,
                        seq:                ^uint32(0),
                        remote_seq:         ^uint32(0), // remote seq number
                        server:             conn,
                        sent_packet_buffer: make([]packet.Packet, 0, 16), // queue of outbound reliable packets
                        remote_acks:        packet.Ack{Data: 0},
                        addr:               *addr,
                }
                conn.connections[*addr] = client
        }</span>

        <span class="cov7" title="4">if n &gt; 5 &amp;&amp; conn.temp[0] == 0 </span><span class="cov4" title="2">{
                // unreliable packet
                ack := binary.BigEndian.Uint32(conn.temp[1:5])
                ack_bitfield := binary.BigEndian.Uint32(conn.temp[5:9])
                if len(buffer) &lt; n-9 </span><span class="cov0" title="0">{
                        return 0, nil, errors.New("buffer too small for packet")
                }</span>
                <span class="cov4" title="2">client.processAck(ack, ack_bitfield)
                copy(buffer, conn.temp[9:n])
                log.Printf("[S] %d %b", ack, ack_bitfield)
                return n - 9, addr, err</span>
        }
        <span class="cov4" title="2">if n &gt; 8 &amp;&amp; conn.temp[0] == 1 </span><span class="cov1" title="1">{
                // reliable packet
                seq := binary.BigEndian.Uint32(conn.temp[1:5])
                client.remote_seq = packet.UpdateAcknowledgements(seq, client.remote_seq, &amp;client.remote_acks)
                ack := binary.BigEndian.Uint32(conn.temp[5:9])
                ack_bitfield := binary.BigEndian.Uint32(conn.temp[9:13])
                if len(buffer) &lt; n-13 </span><span class="cov0" title="0">{
                        return 0, nil, errors.New("buffer too small for packet")
                }</span>
                <span class="cov1" title="1">client.processAck(ack, ack_bitfield)
                copy(buffer, conn.temp[13:n])

                log.Printf("[S] %d %d %b", seq, ack, ack_bitfield)
                return n - 13, addr, err</span>
        }
        // Not sure what this is....
        <span class="cov1" title="1">return n, addr, errors.New("unexpected RUDP header data")</span>
}

// ProcessAck takes the acknowledgements from the remote resource and removes packets from the local
// reliable packet buffer that have been confirmed as sent
func (conn *rUDPConnection) processAck(seq uint32, bitwise uint32) <span class="cov9" title="5">{
        bits := packet.Ack{Data: bitwise}
        count := len(conn.sent_packet_buffer)
        i := 0
        for i &lt; count </span><span class="cov10" title="6">{
                p := conn.sent_packet_buffer[i]
                // check if this packet in the buffer has been verified as delivered.
                // It is verified if either the sequence number is the same as the received sequence number, or
                // if the bitwise bit for that packet is set in the bitwise field(which holds the last 32 acknowledgements)
                if p.Seq == seq || bits.Has(seq-p.Seq-1) </span><span class="cov6" title="3">{
                        //overwrite the packet in the buffer with the last packet in the buffer list
                        conn.sent_packet_buffer[i] = conn.sent_packet_buffer[count-1]
                        // then remove the last packet in the list since we moved it to a new spot in the list
                        count--
                        conn.sent_packet_buffer = conn.sent_packet_buffer[0:count]
                }</span> else<span class="cov6" title="3"> {
                        // check if the packet has taken too long to be verified, which means it was probably lost and
                        // will need to be retransmitted
                        if time.Now().UnixMilli()-p.Timestamp &gt; 200 </span><span class="cov1" title="1">{
                                // it has been 200ms, retransmit the packet and reset the timestamp (use the direct write to the UDP socket)
                                conn.server.conn.WriteToUDPAddrPort(p.Data, conn.addr)
                        }</span>

                        // this packet hasn't been verified, move on to check the next one
                        <span class="cov6" title="3">i++</span>
                }

        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
